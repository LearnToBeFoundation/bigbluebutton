<?xml version="1.0" encoding="utf-8"?>

<!--

BigBlueButton open source conferencing system - http://www.bigbluebutton.org/

Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).

This program is free software; you can redistribute it and/or modify it under the
terms of the GNU Lesser General Public License as published by the Free Software
Foundation; either version 3.0 of the License, or (at your option) any later
version.

BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along
with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.

-->


<pres:MDIWindow xmlns:mx="http://www.adobe.com/2006/mxml" 
	xmlns:thumb="org.bigbluebutton.modules.present.views.*"
	xmlns:pres="flexlib.mdi.containers.*"
	xmlns:code="http://code.google.com/p/flexlib/" 
	xmlns:containers="flexlib.containers.*"
	xmlns:mate="http://mate.asfusion.com/"
	showCloseButton="false" layout="absolute"
	verticalScrollPolicy="off" 
	horizontalScrollPolicy="off" 
	showControls="true" resize="maximizeHandler()"
  styleNameFocus="presentationWindowStyleFocus"
  styleNameNoFocus="presentationWindowStyleNoFocus"
	implements="org.bigbluebutton.common.IBbbModuleWindow"
	initialize="init()"
	creationComplete="onCreationComplete()" 
	width="{DEFAULT_WINDOW_WIDTH}" height="{DEFAULT_WINDOW_HEIGHT}" 
	x="{DEFAULT_X_POSITION}" y="{DEFAULT_Y_POSITION}"
	title="{ResourceUtil.getInstance().getString('bbb.presentation.titleWithPres',[currentPresentation])}"
	xmlns:views="org.bigbluebutton.modules.present.ui.views.*"
	>
	
	<mate:Dispatcher id="globalDispatcher" />
	<mate:Listener type="{ShortcutEvent.FOCUS_PRESENTATION_WINDOW}" method="focusWindow" />
	<mate:Listener type="{MadePresenterEvent.SWITCH_TO_PRESENTER_MODE}" method="handleBecomePresenter" />
	<mate:Listener type="{MadePresenterEvent.SWITCH_TO_VIEWER_MODE}" method="handleBecomeViewer" />
	<mate:Listener type="{PresentationChangedEvent.PRESENTATION_CHANGED_EVENT}" method="handlePresentationChangedEvent" />
  <mate:Listener type="{NavigationEvent.BIND_KEYBOARD_EVENT}" method="bindToKeyboardEvents" />
	<mate:Listener type="{UploadEvent.CLEAR_PRESENTATION}" method="clearPresentation" />
	<mate:Listener type="{RemovePresentationEvent.PRESENTATION_REMOVED_EVENT}" method="handlePresentationRemoved" />
	<mate:Listener type="{DisplaySlideEvent.DISPLAY_SLIDE_EVENT}" method="handleDisplaySlideEvent" />
	<mate:Listener type="{AddOverlayCanvasEvent.ADD_OVERLAY_CANVAS}" method="addOverlayCanvas" />
	<mate:Listener type="{LocaleChangeEvent.LOCALE_CHANGED}" method="localeChanged" />	
	<mate:Listener type="{ShortcutEvent.UPLOAD_PRESENTATION}" method="remoteUpload" />
	<mate:Listener type="{ShortcutEvent.PREVIOUS_SLIDE}" method="remotePrevious" />
	<mate:Listener type="{ShortcutEvent.SELECT_SLIDES}" method="remoteSelect" />
	<mate:Listener type="{ShortcutEvent.NEXT_SLIDE}" method="remoteNext" />
	<mate:Listener type="{ShortcutEvent.FIT_TO_WIDTH}" method="remoteWidth" />
	<mate:Listener type="{ShortcutEvent.FIT_TO_PAGE}" method="remotePage" />	
	<mate:Listener type="{ShortcutEvent.MINIMIZE_PRES}" method="remoteMinimize" />
	<mate:Listener type="{ShortcutEvent.MAXIMIZE_PRES}" method="remoteMaximize" />
	
	
	<mx:Script>
		<![CDATA[
      import flash.geom.Point;      
      import flexlib.containers.DockableToolBar;
      import flexlib.mdi.events.MDIWindowEvent;      
      import mx.binding.utils.BindingUtils;
      import mx.collections.ArrayCollection;
      import mx.collections.Sort;
      import mx.containers.TitleWindow;
      import mx.core.Application;
      import mx.effects.Move;
      import mx.events.ResizeEvent;
      import mx.managers.PopUpManager;
      import mx.rpc.events.*;     
      import org.bigbluebutton.common.IBbbCanvas;
      import org.bigbluebutton.common.Images;
      import org.bigbluebutton.common.LogUtil;
      import org.bigbluebutton.common.events.LocaleChangeEvent;
      import org.bigbluebutton.core.UsersUtil;
      import org.bigbluebutton.main.events.MadePresenterEvent;
      import org.bigbluebutton.main.events.ShortcutEvent;
      import org.bigbluebutton.main.views.MainCanvas;
      import org.bigbluebutton.modules.present.commands.GoToNextPageCommand;
      import org.bigbluebutton.modules.present.commands.GoToPrevPageCommand;
      import org.bigbluebutton.modules.present.commands.ChangePresentationCommand;
      import org.bigbluebutton.modules.present.events.AddOverlayCanvasEvent;
      import org.bigbluebutton.modules.present.events.DisplaySlideEvent;
      import org.bigbluebutton.modules.present.events.NavigationEvent;
      import org.bigbluebutton.modules.present.events.PresentationChangedEvent;
      import org.bigbluebutton.modules.present.events.PresentationEvent;
      import org.bigbluebutton.modules.present.events.PresenterCommands;
      import org.bigbluebutton.modules.present.events.UploadEvent;
      import org.bigbluebutton.modules.present.events.RemovePresentationEvent;
      import org.bigbluebutton.modules.present.events.WindowResizedEvent;
      import org.bigbluebutton.modules.present.managers.Slide;
      import org.bigbluebutton.modules.present.model.Page;
      import org.bigbluebutton.modules.present.model.Presentation;
      import org.bigbluebutton.modules.present.model.PresentationModel;
      import org.bigbluebutton.modules.present.ui.views.PresentOptions;
      import org.bigbluebutton.modules.whiteboard.events.WhiteboardButtonEvent;
      import org.bigbluebutton.util.i18n.ResourceUtil;
      import mx.containers.TabNavigator;
         		
      private static const LOG:String = "Present::PresentationWindow - ";
      
      public static const TITLE:String = "Presentation";
			private static const NEXT_BUTTON:String = "Next";
			private static const PREVIOUS_BUTTON:String = "Previous";
			private static const GOTO_PAGE_BUTTON:String = "Go to Page...";
						
			[Bindable] 
      private var thumbY:Number;
			public var uploadWindow:FileUploadWindow = null;
			private var pageDialog:GotoPageDialog;
			
			[Bindable] private var DEFAULT_X_POSITION:Number = 237;
			[Bindable] private var DEFAULT_Y_POSITION:Number = 0;
			
			[Bindable] private var CONTROL_BAR_HEIGHT:Number;
			private static const TOP_WINDOW_BORDER:Number = 30;
			private static const WIDTH_PADDING:Number = 6;

			[Bindable] private var DEFAULT_WINDOW_WIDTH:Number = 510;
			[Bindable] private var DEFAULT_WINDOW_HEIGHT:Number = 451;
			[Bindable] private var viewportW:Number = 451;
			[Bindable] private var viewportH:Number = 451;
			
			// Init to the size of the window.
			private var currentSlideWidth:Number = DEFAULT_WINDOW_WIDTH;
			private var currentSlideHeight:Number = DEFAULT_WINDOW_HEIGHT;
									
			private var mouseDown:Boolean = false;

			[Bindable] private var currentPresentation:String = "";
			
			[Bindable] private var baseIndex:int; 
			[Bindable] private var presentOptions:PresentOptions;
			
			private var keyCombos:Object;
			private var localDispatcher:Dispatcher = new Dispatcher();
			
			[Bindable] private var presTabsData:ArrayCollection;

			private function init():void{
				presentOptions = new PresentOptions();
				baseIndex = presentOptions.baseTabIndex;;
			}
			
			private function onCreationComplete():void{
				thumbY = this.height - 160;
                
				bindKeyboardEvents();
				this.addEventListener(MDIWindowEvent.RESIZE_END, onResizeEndEvent);
				resourcesChanged();
				
				titleBarOverlay.tabIndex = baseIndex;
				
				minimizeBtn.tabIndex = baseIndex+1;
				maximizeRestoreBtn.tabIndex = baseIndex+2;
				closeBtn.tabIndex = baseIndex+3;
				
				slideView.slideLoader.tabIndex = baseIndex+4;
				hotkeyCapture();
                
		        //Necessary now because of module loading race conditions
		        var t:Timer = new Timer(2000, 1);
		        t.addEventListener(TimerEvent.TIMER, delayedCallback);
		        t.start();

		        if (UsersUtil.amIPresenter()) {
		          becomePresenter();
		        } else {
		          becomeViewer();
		        }
			}
	  private function delayedCallback(event:TimerEvent):void {
	  	syncTabs();
	  	addWhiteboardToolbar(event);
	  }

      private function addWhiteboardToolbar(event:TimerEvent):void {
        trace(LOG + "Sending event to add whiteboard canvas.");
         // Tell the WhiteboardManager to add the toolbar
         var e:WhiteboardButtonEvent = new WhiteboardButtonEvent(WhiteboardButtonEvent.WHITEBOARD_ADDED_TO_PRESENTATION);
         e.window = this;
         dispatchEvent(e);
      }
            
			private function hotkeyCapture():void{
			    LogUtil.debug("Entering hotkeyCapture");
			    this.addEventListener(KeyboardEvent.KEY_DOWN, handleKeyDown);
			    ResourceUtil.getInstance().addEventListener(Event.CHANGE, localeChanged); // Listen for locale changing
			    LogUtil.debug("Leaving hotkeyCapture");
		    }
			
			private function loadKeyCombos(modifier:String):void {
				keyCombos = new Object(); // always start with a fresh array
				keyCombos[modifier+(ResourceUtil.getInstance().getString('bbb.shortcutkey.present.focusslide') as String)] = ShortcutEvent.FOCUS_SLIDE;
				
				keyCombos[modifier+(ResourceUtil.getInstance().getString('bbb.shortcutkey.general.maximize') as String)] = ShortcutEvent.MAXIMIZE_PRES;
				keyCombos[modifier+(ResourceUtil.getInstance().getString('bbb.shortcutkey.general.minimize') as String)] = ShortcutEvent.MINIMIZE_PRES;
				
				keyCombos[modifier+(ResourceUtil.getInstance().getString('bbb.shortcutkey.present.upload') as String)] = ShortcutEvent.UPLOAD_PRESENTATION;
				keyCombos[modifier+(ResourceUtil.getInstance().getString('bbb.shortcutkey.present.previous') as String)] = ShortcutEvent.PREVIOUS_SLIDE;
				keyCombos[modifier+(ResourceUtil.getInstance().getString('bbb.shortcutkey.present.select') as String)] = ShortcutEvent.SELECT_SLIDES;
				keyCombos[modifier+(ResourceUtil.getInstance().getString('bbb.shortcutkey.present.next') as String)] = ShortcutEvent.NEXT_SLIDE;
				keyCombos[modifier+(ResourceUtil.getInstance().getString('bbb.shortcutkey.present.fitWidth') as String)] = ShortcutEvent.FIT_TO_WIDTH;
				keyCombos[modifier+(ResourceUtil.getInstance().getString('bbb.shortcutkey.present.fitPage') as String)] = ShortcutEvent.FIT_TO_PAGE;
				//keyCombos[modifier+(ResourceUtil.getInstance().getString('bbb.shortcutkey.whiteboard.undo') as String)] = ShortcutEvent.UNDO_WHITEBOARD;

				keyCombos[Keyboard.LEFT] = ShortcutEvent.PREVIOUS_SLIDE;
				keyCombos[Keyboard.RIGHT] = ShortcutEvent.NEXT_SLIDE;
				keyCombos[Keyboard.PAGE_UP] = ShortcutEvent.PREVIOUS_SLIDE;
				keyCombos[Keyboard.PAGE_DOWN] = ShortcutEvent.NEXT_SLIDE;
			}
			
			// Handle presentation-scope hotkeys
			private function handleKeyDown(e:KeyboardEvent) :void {
				var modifier:String = ExternalInterface.call("determineModifier");
				loadKeyCombos(modifier);
				  
				var keyPress:String = (e.ctrlKey  ? "control+" : "") + (e.shiftKey ? "shift+"   : "") + (e.altKey   ? "alt+"     : "") + e.keyCode;
				                          
				if (keyCombos[keyPress]) {
				    //globalDispatcher.dispatchEvent(new ShortcutEvent(keyCombos[keyPress]));
				    localDispatcher.dispatchEvent(new ShortcutEvent(keyCombos[keyPress]));
				}
			}
			
			private function remoteMinimize(e:ShortcutEvent):void{
				if (!minimized){
					this.minimize();
				}
			}
			
			private function remoteMaximize(e:ShortcutEvent):void{
				if (!maximized && !minimized){
					this.maximize();
				}
				else{
					this.restore();
				}				
			}
			
			private function focusWindow(e:ShortcutEvent):void{
				focusManager.setFocus(titleBarOverlay);
			}
			
			private function maximizeHandler():void {
				// When the window is maximized, we want to resize the slide maintaining the aspect ratio.			
				fitSlideToWindowMaintainingAspectRatio();
				//Remove focus from the maximize button in case the user presses the space bar, the window doesn't get maximized again.	
				stage.focus = this; 
			}
			
			private function onResizeEndEvent(event:MDIWindowEvent):void {
				fitSlideToWindowMaintainingAspectRatio();
			}
			
			[Bindable] private var fitToPage:Boolean = false;
			
			private function fitSlideToWindowMaintainingAspectRatio():void {
				if (this.minimized) return;
				
				// Send the available space to display the slide.				
				sendWindowResizedEvent((this.width - WIDTH_PADDING), (this.height - CONTROL_BAR_HEIGHT - TOP_WINDOW_BORDER));
			}
			
			/*
			 * Notify the slide container telling it the available dimensions to display the slide.
			 */
